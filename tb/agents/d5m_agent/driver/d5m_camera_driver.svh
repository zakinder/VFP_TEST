// Class: d5m_camera_driver
// This class which extended from uvm driver pull data items generated by a sequencer and drive it to the DUT. In run phase methods are used for read and write operation to dut through dut interface handle.

class d5m_camera_driver extends uvm_driver #(d5m_camera_transaction);


    // handle: d5m_camera_vif
    // dut interface
    protected virtual d5m_camera_if d5m_camera_vif;
    
    protected int     id;
    
    `uvm_component_utils_begin(d5m_camera_driver)
        `uvm_field_int(id, UVM_DEFAULT)
    `uvm_component_utils_end
    
    // Function: new
    function new (string name, uvm_component parent);
        super.new(name, parent);
    endfunction: new
    
    // Function: build_phase
    // In this phase, config the dut interface handle through get method.
    function void build_phase (uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual d5m_camera_if)::get(this, "", "d5m_camera_vif", d5m_camera_vif))
        `uvm_fatal("NOVIF", {"virtual interface must be set for: ",get_full_name(), ".d5m_camera_vif"});
    endfunction: build_phase
    
    
    
    

    // Method: run_phase
    // In this method, fork join constructs are used to separate threads that drive each of the channels.
    //
    //- reset_signals : this method reset the signals to dut
    //- d5m_frame     : this method drive data to dut and get response from dut
    virtual task run_phase (uvm_phase phase);
        fork
        reset_signals();
        d5m_frame();
        join
    endtask: run_phase



    // Function: reset_signals
    // Reset the dut axi4 lite and d5m_cam_mod input signals when system reset is asserted from low to high.
    virtual protected task reset_signals();
        forever begin
            @(posedge d5m_camera_vif.ARESETN);
            d5m_camera_vif.axi4.AWADDR        <=  8'h0;
            d5m_camera_vif.axi4.AWPROT        <=  3'h0;
            d5m_camera_vif.axi4.AWVALID       <=  1'b0;
            d5m_camera_vif.axi4.WDATA         <= 32'h0;
            d5m_camera_vif.axi4.WSTRB         <=  4'h0;
            d5m_camera_vif.axi4.WVALID        <=  1'b0;
            d5m_camera_vif.axi4.BREADY        <=  1'b0;
            d5m_camera_vif.axi4.ARADDR        <=  8'h0;
            d5m_camera_vif.axi4.ARPROT        <=  3'h0;
            d5m_camera_vif.axi4.ARVALID       <=  1'b0;
            d5m_camera_vif.axi4.RREADY        <=  1'b0;
            d5m_camera_vif.d5p.iImageTypeTest <=  1'b0;
            d5m_camera_vif.d5p.iReadyToRead   <=  1'b0;
            d5m_camera_vif.d5p.fvalid         <=  1'b0;
            d5m_camera_vif.d5p.lvalid         <=  1'b0;
        end
    endtask: reset_signals
    
    
    // Function: d5m_frame
    // In this method, drive the signals from defined seq in uvm_sequence.
    //
    //- seq_item_port.get_next_item : Get next item from the sequencer
    //- drive_transfer : this method drive data to dut and get response from dut
    //- seq_item_port.item_done : Tell the sequence that driver has finished current item
    virtual protected task d5m_frame();
        forever begin
            @(posedge d5m_camera_vif.clkmm);
            seq_item_port.get_next_item(req);
            drive_transfer(req);
            seq_item_port.item_done();
        end
    endtask: d5m_frame
    
    

    // Function: drive_transfer
    // This method which is master to dut axi4lite interface read or write data at given address using bus handshaking protocol.First valid address is transmit and then wait for valid response in given time of 61 clock cycles in address_channel method. Timeout accord on 62 clock cycle, if no response is asserted high on bvalid signal from dut and timeout is flagged using uvm_error macro. If valid response is asserted then data_channel method write or read data depending on case statement.
    //
    //- address_channel : this method drive the axi4lite write/read address channels.
    //- data_channel : this method read or write the the data at given address.
    virtual protected task drive_transfer (d5m_camera_transaction d5m_tx);
        address_channel(d5m_tx);
        data_channel(d5m_tx);
    endtask: drive_transfer





    // Function: address_channel
    // In this method, drive axi4 read/write addresses | d5m read/write.Note need to rewite this method.
    //
    //- case : AXI4_WRITE AXI4_READ D5M_WRITE IMAGE_READ
    //- drive_write_address_channel : axi4 write address
    //- drive_read_address_channel : axi4 read address
    //- d5m_data_phase : write data to d5m mod
    //- read_d5m_phase : read data from d5m mod
    
    virtual protected task address_channel (d5m_camera_transaction d5m_tx);
        case (d5m_tx.d5m_txn)
            AXI4_WRITE : drive_write_address_channel(d5m_tx);
            AXI4_READ  : drive_read_address_channel(d5m_tx);
            D5M_WRITE  : d5m_data_phase(d5m_tx);
            IMAGE_READ : read_d5m_phase(d5m_tx);
        endcase
    endtask: address_channel
    
    
    
    // Function: data_channel
    // In this method, drive axi4 address channel | d5m read/write
    //
    //- case : AXI4_WRITE AXI4_READ D5M_WRITE IMAGE_READ
    //- drive_write_data_channel : axi4 write data
    //- drive_read_data_channel : axi4 read data
    //- d5m_data_phase : write data to d5m mod
    //- read_d5m_phase : read data from d5m mod
    
    virtual protected task data_channel (d5m_camera_transaction d5m_tx);
        bit[31:0] rw_data;
        bit err;
        rw_data = d5m_tx.axi4_lite.data;
        case (d5m_tx.d5m_txn)
            AXI4_WRITE : drive_write_data_channel(d5m_tx);
            AXI4_READ  : drive_read_data_channel(rw_data, err);
            D5M_WRITE  : d5m_data_phase(d5m_tx);
            IMAGE_READ : read_d5m_phase(d5m_tx);
        endcase    
    endtask: data_channel
    

    // Function: read_d5m_phase
    // In this method, config test type during read operation and wait for end of frame pulse
    //
    //- iImageTypeTest : axi4 write address
    //- iReadyToRead : axi4 read address
    //- eof : write data to d5m mod
    virtual protected task read_d5m_phase(d5m_camera_transaction d5m_tx);
            @(posedge d5m_camera_vif.clkmm);
            d5m_camera_vif.d5p.iImageTypeTest  <= 1'b0;
            d5m_camera_vif.d5p.iReadyToRead    <= 1'b1;
        forever begin
            @(posedge d5m_camera_vif.clkmm);
            if (d5m_camera_vif.d5m.eof) break;
        end
    endtask: read_d5m_phase
    
    

    
    // Function: d5m_data_phase
    // In this method, write data to d5m camera mod
    //
    //- case : AXI4_WRITE AXI4_READ D5M_WRITE IMAGE_READ
    //- drive_write_address_channel : axi4 write address
    //- drive_read_address_channel : axi4 read address
    //- d5m_data_phase : write data to d5m mod
    //- read_d5m_phase : read data from d5m mod
    virtual protected task d5m_data_phase (d5m_camera_transaction d5m_tx);
        bit[23:0] rw_data;
        bit err;
        bit ifvalid;
        bit ilvalid;
        bit iImageTypeTest;
        ifvalid          = d5m_tx.d5p.fvalid;
        ilvalid          = d5m_tx.d5p.lvalid;
        iImageTypeTest   = d5m_tx.d5p.iImageTypeTest;
        rw_data          = d5m_tx.d5p.rgb;
        d5m_write_idata(rw_data,ilvalid,ifvalid,iImageTypeTest, err);
    endtask: d5m_data_phase
    
    
    
    // Function: d5m_write_idata
    // In this method, drive axi4 address channel | d5m read/write
    //
    //- iReadyToRead : axi4 write address
    //- iImageTypeTest : axi4 read address
    //- rgb : write data to d5m mod
    //- fvalid : read data from d5m mod
    //- lvalid : read data from d5m mod
    virtual protected task d5m_write_idata (bit[23:0] iRgb,bit ilvalid,bit ifvalid,bit iImageTypeTest, output bit error);
        d5m_camera_vif.d5p.iReadyToRead   <= 1'b0;
        d5m_camera_vif.d5p.iImageTypeTest <= iImageTypeTest;
        d5m_camera_vif.d5p.rgb            <= iRgb;
        d5m_camera_vif.d5p.fvalid         <= ifvalid;
        d5m_camera_vif.d5p.lvalid         <= ilvalid;
    endtask: d5m_write_idata


    // Function: drive_write_address_channel
    // In this method, axi4lite write address
    //
    //- drive_write_address_channel : axi4 write address
    //- drive_read_address_channel : axi4 read address
    //- d5m_data_phase : write data to d5m mod
    //- read_d5m_phase : read data from d5m mod
    virtual protected task drive_write_address_channel (d5m_camera_transaction d5m_tx);
        int axi_lite_ctr;
        d5m_camera_vif.axi4.AWADDR  <= {8'h0, d5m_tx.axi4_lite.addr};
        d5m_camera_vif.axi4.AWPROT  <= 3'h0;
        d5m_camera_vif.axi4.AWVALID <= 1'b1;
        //wait for write response
        for(axi_lite_ctr = 0; axi_lite_ctr <= 62; axi_lite_ctr ++) begin
            @(posedge d5m_camera_vif.clkmm);
            if (d5m_camera_vif.axi4.BVALID) break;
        end
        if (axi_lite_ctr == 62) begin
            `uvm_error("axi_lite_master_driver","AWVALID timeout");
        end    
    endtask: drive_write_address_channel

    // Function: drive_write_data_channel
    // In this method, axi4lite write data
    //
    //- WDATA   : axi4 write address
    //- WVALID  : axi4 read address
    //- WREADY  : write data to d5m mod
    //- AWVALID : read data from d5m mod
    virtual protected task drive_write_data_channel (d5m_camera_transaction d5m_tx);
        int axi_lite_ctr;
        d5m_camera_vif.axi4.WDATA  <= d5m_tx.axi4_lite.data;
        d5m_camera_vif.axi4.WSTRB  <= 4'hf;
        d5m_camera_vif.axi4.WVALID <= 1'b1;
        @(posedge d5m_camera_vif.clkmm);
            for(axi_lite_ctr = 0; axi_lite_ctr <= 62; axi_lite_ctr ++) begin
            @(posedge d5m_camera_vif.clkmm);
            //------------------------------
            if (d5m_camera_vif.axi4.WREADY) 
                d5m_camera_vif.axi4.AWADDR  <= 8'h0;
                d5m_camera_vif.axi4.AWPROT  <= 3'h0;
                d5m_camera_vif.axi4.AWVALID <= 1'b0; 
            break;
            //------------------------------
            end
            if (axi_lite_ctr == 62) begin
            `uvm_error("axi_lite_master_driver","AWVALID timeout");
            end
        @(posedge d5m_camera_vif.clkmm);
            d5m_camera_vif.axi4.WDATA  <= 32'h0;
            d5m_camera_vif.axi4.WSTRB  <= 4'h0;
            d5m_camera_vif.axi4.WVALID <= 1'b0;
        //wait for write response
        for(axi_lite_ctr = 0; axi_lite_ctr <= 62; axi_lite_ctr ++) begin
            @(posedge d5m_camera_vif.clkmm);
            if (d5m_camera_vif.axi4.BVALID) break;
        end
        if (axi_lite_ctr == 62) begin
            `uvm_error("axi_lite_master_driver","BVALID timeout");
        end
        else begin
            if (d5m_camera_vif.axi4.BVALID == 1'b1 && d5m_camera_vif.axi4.BRESP != 2'h0)
            `uvm_error("axi_lite_master_driver","Received ERROR Write Response");
            d5m_camera_vif.axi4.BREADY <= d5m_camera_vif.axi4.BVALID;
         @(posedge d5m_camera_vif.clkmm);
        end
    endtask: drive_write_data_channel
    
    
    
    
    

    // Function: drive_read_address_channel
    // In this method, axi4lite write read address
    //
    //- ARADDR : axi4 write address
    //- ARVALID : axi4 read address
    //- ARREADY : write data to d5m mod
    //- ARPROT : read data from d5m mod
    virtual protected task drive_read_address_channel (d5m_camera_transaction d5m_tx);
        int axi_lite_ctr;
        d5m_camera_vif.axi4.ARADDR  <= {8'h0, d5m_tx.axi4_lite.addr};
        d5m_camera_vif.axi4.ARPROT  <= 3'h0;
        d5m_camera_vif.axi4.ARVALID <= 1'b1;
        for(axi_lite_ctr = 0; axi_lite_ctr <= 62; axi_lite_ctr ++) begin
            @(posedge d5m_camera_vif.clkmm);
            if (d5m_camera_vif.axi4.ARREADY) break;
        end
        if (axi_lite_ctr == 62) begin
            `uvm_error("axi_lite_master_driver","ARVALID timeout");
        end
        @(posedge d5m_camera_vif.clkmm);
            d5m_camera_vif.axi4.ARADDR  <= 8'h0;
            d5m_camera_vif.axi4.ARPROT  <= 3'h0;
            d5m_camera_vif.axi4.ARVALID <= 1'b0;    
    endtask: drive_read_address_channel
    
    

    // Function: drive_read_data_channel
    // In this method, axi4lite read data
    //
    //- RDATA  : axi4 write address
    //- RVALID : axi4 read address
    //- RREADY : write data to d5m mod
    //- RRESP  : read data from d5m mod
    virtual protected task drive_read_data_channel (output bit [31:0] data, output bit error);
        int axi_lite_ctr;
        for(axi_lite_ctr = 0; axi_lite_ctr <= 62; axi_lite_ctr ++) begin
            @(posedge d5m_camera_vif.clkmm);
            if (d5m_camera_vif.axi4.RVALID) break;
        end
        data = d5m_camera_vif.axi4.RDATA;
        if (axi_lite_ctr == 62) begin
            `uvm_error("axi_lite_master_driver","RVALID timeout");
        end
        else begin
        if (d5m_camera_vif.axi4.RVALID == 1'b1 && d5m_camera_vif.axi4.RRESP != 2'h0)
            `uvm_error("axi_lite_master_driver","Received ERROR Read Response");
            d5m_camera_vif.axi4.RREADY <= d5m_camera_vif.axi4.RVALID;
            @(posedge d5m_camera_vif.clkmm);
        end
    endtask: drive_read_data_channel
endclass: d5m_camera_driver